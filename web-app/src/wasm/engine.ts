/**
 * WASM Engine wrapper for DrawConnect Web
 *
 * This module provides a JavaScript interface to the DrawConnect WASM core engine.
 * It replaces Tauri's invoke() calls with direct WASM method calls.
 */

// Types will be generated by wasm-bindgen, but we define them here for TypeScript
export interface CanvasInfo {
  width: number
  height: number
  dpi: number
  background_color: string
}

export interface LayerInfo {
  id: string
  name: string
  visible: boolean
  locked: boolean
  opacity: number
  blend_mode: string
}

export interface BrushInfo {
  name: string
  category: string
  size: number
  opacity: number
  hardness: number
}

export interface ColorResult {
  hex: string
  r: number
  g: number
  b: number
  a: number
}

export interface SelectionInfo {
  is_active: boolean
  bounds: [number, number, number, number] | null
  mode: string
  feather: number
  shape_type: string
}

// Placeholder for the WASM module - will be loaded dynamically
let wasmModule: any = null
let engine: any = null

/**
 * Initialize the WASM engine
 */
export async function initEngine(): Promise<void> {
  try {
    // Dynamic import of the WASM module
    // The actual path will be set after building with wasm-pack
    wasmModule = await import('./pkg/drawconnect_core_wasm')
    await wasmModule.default()

    // Create engine instance
    engine = new wasmModule.WasmDrawEngine()

    console.log('DrawConnect WASM Engine initialized')
  } catch (error) {
    console.error('Failed to initialize WASM engine:', error)
    throw error
  }
}

/**
 * Check if the engine is initialized
 */
export function isEngineReady(): boolean {
  return engine !== null
}

/**
 * Get the engine version
 */
export function getVersion(): string {
  if (!wasmModule) throw new Error('Engine not initialized')
  return wasmModule.get_version()
}

// ============================================================================
// Canvas Commands
// ============================================================================

export async function createCanvas(
  width: number,
  height: number,
  dpi?: number,
  background?: string
): Promise<CanvasInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.createCanvas(width, height, dpi, background)
}

export async function openImageFromBytes(data: Uint8Array): Promise<CanvasInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.openImageFromBytes(data)
}

export async function getCanvasInfo(): Promise<CanvasInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.getCanvasInfo()
}

export async function renderCanvas(): Promise<string> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.renderCanvas()
}

// ============================================================================
// Layer Commands
// ============================================================================

export async function getLayers(): Promise<LayerInfo[]> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.getLayers()
}

export async function addLayer(name: string): Promise<LayerInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.addLayer(name)
}

export async function deleteLayer(layerId: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.deleteLayer(layerId)
}

export async function setActiveLayer(layerId: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setActiveLayer(layerId)
}

export async function setLayerVisibility(layerId: string, visible: boolean): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setLayerVisibility(layerId, visible)
}

export async function setLayerOpacity(layerId: string, opacity: number): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setLayerOpacity(layerId, opacity)
}

export async function moveLayerUp(layerId: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.moveLayerUp(layerId)
}

export async function moveLayerDown(layerId: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.moveLayerDown(layerId)
}

export async function duplicateLayer(layerId: string): Promise<LayerInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.duplicateLayer(layerId)
}

export async function mergeLayerDown(layerId: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.mergeLayerDown(layerId)
}

// ============================================================================
// Brush Commands
// ============================================================================

export async function getBrushes(): Promise<BrushInfo[]> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.getBrushes()
}

export async function setBrush(brushName: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setBrush(brushName)
}

export async function setBrushColor(hex: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setBrushColor(hex)
}

export async function setBrushSize(size: number): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setBrushSize(size)
}

export async function setBrushOpacity(opacity: number): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setBrushOpacity(opacity)
}

export async function setBrushMode(mode: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setBrushMode(mode)
}

// ============================================================================
// Stroke Commands
// ============================================================================

export async function beginStroke(): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.beginStroke()
}

export async function addStrokePoint(
  x: number,
  y: number,
  pressure: number,
  tiltX: number,
  tiltY: number,
  timestamp: number
): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.addStrokePoint(x, y, pressure, tiltX, tiltY, timestamp)
}

export async function endStroke(): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.endStroke()
}

// ============================================================================
// Undo/Redo Commands
// ============================================================================

export async function undo(): Promise<boolean> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.undo()
}

export async function redo(): Promise<boolean> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.redo()
}

export function canUndo(): boolean {
  if (!engine) return false
  return engine.canUndo()
}

export function canRedo(): boolean {
  if (!engine) return false
  return engine.canRedo()
}

// ============================================================================
// Color Commands
// ============================================================================

export async function pickColor(x: number, y: number): Promise<ColorResult> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.pickColor(x, y)
}

export async function floodFill(x: number, y: number, hex: string, tolerance: number): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.floodFill(x, y, hex, tolerance)
}

// ============================================================================
// Selection Commands
// ============================================================================

export async function selectRect(x: number, y: number, width: number, height: number): Promise<SelectionInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.selectRect(x, y, width, height)
}

export async function selectLasso(points: Array<[number, number]>): Promise<SelectionInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.selectLasso(points)
}

export async function clearSelection(): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.clearSelection()
}

export async function selectAll(): Promise<SelectionInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.selectAll()
}

export async function invertSelection(): Promise<SelectionInfo> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.invertSelection()
}

export async function setSelectionMode(mode: string): Promise<void> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.setSelectionMode(mode)
}

// ============================================================================
// Export Commands
// ============================================================================

export async function exportPng(): Promise<Uint8Array> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.exportPng()
}

export async function exportJpeg(quality: number): Promise<Uint8Array> {
  if (!engine) throw new Error('Engine not initialized')
  return engine.exportJpeg(quality)
}

// ============================================================================
// File Helpers (Web-specific implementations)
// ============================================================================

/**
 * Open a file picker and load an image
 */
export async function openImageFile(): Promise<CanvasInfo | null> {
  return new Promise((resolve, reject) => {
    const input = document.createElement('input')
    input.type = 'file'
    input.accept = 'image/*'

    input.onchange = async () => {
      const file = input.files?.[0]
      if (!file) {
        resolve(null)
        return
      }

      try {
        const arrayBuffer = await file.arrayBuffer()
        const result = await openImageFromBytes(new Uint8Array(arrayBuffer))
        resolve(result)
      } catch (error) {
        reject(error)
      }
    }

    input.click()
  })
}

/**
 * Save canvas as PNG file
 */
export async function saveAsPng(filename: string = 'drawing.png'): Promise<void> {
  const pngData = await exportPng()
  const blob = new Blob([pngData], { type: 'image/png' })
  const url = URL.createObjectURL(blob)

  const link = document.createElement('a')
  link.href = url
  link.download = filename
  link.click()

  URL.revokeObjectURL(url)
}

/**
 * Save canvas as JPEG file
 */
export async function saveAsJpeg(filename: string = 'drawing.jpg', quality: number = 90): Promise<void> {
  const jpegData = await exportJpeg(quality)
  const blob = new Blob([jpegData], { type: 'image/jpeg' })
  const url = URL.createObjectURL(blob)

  const link = document.createElement('a')
  link.href = url
  link.download = filename
  link.click()

  URL.revokeObjectURL(url)
}
